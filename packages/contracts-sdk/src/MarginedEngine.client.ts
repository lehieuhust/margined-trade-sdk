/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {Uint128, Side, PnlCalcOption, Direction, Addr, ArrayOfPosition, Position, Integer, AssetInfo, Boolean} from "./types";
import {InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg, ConfigResponse, PauserResponse, HooksResponse, StateResponse, PositionUnrealizedPnlResponse} from "./MarginedEngine.types";
export interface MarginedEngineReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  state: () => Promise<StateResponse>;
  getPauser: () => Promise<PauserResponse>;
  isWhitelisted: ({
    address
  }: {
    address: string;
  }) => Promise<Boolean>;
  getWhitelist: () => Promise<HooksResponse>;
  position: ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }) => Promise<Position>;
  allPositions: ({
    trader
  }: {
    trader: string;
  }) => Promise<ArrayOfPosition>;
  unrealizedPnl: ({
    calcOption,
    trader,
    vamm
  }: {
    calcOption: PnlCalcOption;
    trader: string;
    vamm: string;
  }) => Promise<PositionUnrealizedPnlResponse>;
  cumulativePremiumFraction: ({
    vamm
  }: {
    vamm: string;
  }) => Promise<Integer>;
  marginRatio: ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }) => Promise<Integer>;
  freeCollateral: ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }) => Promise<Integer>;
  balanceWithFundingPayment: ({
    trader
  }: {
    trader: string;
  }) => Promise<Uint128>;
  positionWithFundingPayment: ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }) => Promise<Position>;
}
export class MarginedEngineQueryClient implements MarginedEngineReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.state = this.state.bind(this);
    this.getPauser = this.getPauser.bind(this);
    this.isWhitelisted = this.isWhitelisted.bind(this);
    this.getWhitelist = this.getWhitelist.bind(this);
    this.position = this.position.bind(this);
    this.allPositions = this.allPositions.bind(this);
    this.unrealizedPnl = this.unrealizedPnl.bind(this);
    this.cumulativePremiumFraction = this.cumulativePremiumFraction.bind(this);
    this.marginRatio = this.marginRatio.bind(this);
    this.freeCollateral = this.freeCollateral.bind(this);
    this.balanceWithFundingPayment = this.balanceWithFundingPayment.bind(this);
    this.positionWithFundingPayment = this.positionWithFundingPayment.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  state = async (): Promise<StateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      state: {}
    });
  };
  getPauser = async (): Promise<PauserResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pauser: {}
    });
  };
  isWhitelisted = async ({
    address
  }: {
    address: string;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_whitelisted: {
        address
      }
    });
  };
  getWhitelist = async (): Promise<HooksResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_whitelist: {}
    });
  };
  position = async ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }): Promise<Position> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        trader,
        vamm
      }
    });
  };
  allPositions = async ({
    trader
  }: {
    trader: string;
  }): Promise<ArrayOfPosition> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_positions: {
        trader
      }
    });
  };
  unrealizedPnl = async ({
    calcOption,
    trader,
    vamm
  }: {
    calcOption: PnlCalcOption;
    trader: string;
    vamm: string;
  }): Promise<PositionUnrealizedPnlResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      unrealized_pnl: {
        calc_option: calcOption,
        trader,
        vamm
      }
    });
  };
  cumulativePremiumFraction = async ({
    vamm
  }: {
    vamm: string;
  }): Promise<Integer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      cumulative_premium_fraction: {
        vamm
      }
    });
  };
  marginRatio = async ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }): Promise<Integer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      margin_ratio: {
        trader,
        vamm
      }
    });
  };
  freeCollateral = async ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }): Promise<Integer> => {
    return this.client.queryContractSmart(this.contractAddress, {
      free_collateral: {
        trader,
        vamm
      }
    });
  };
  balanceWithFundingPayment = async ({
    trader
  }: {
    trader: string;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      balance_with_funding_payment: {
        trader
      }
    });
  };
  positionWithFundingPayment = async ({
    trader,
    vamm
  }: {
    trader: string;
    vamm: string;
  }): Promise<Position> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_with_funding_payment: {
        trader,
        vamm
      }
    });
  };
}
export interface MarginedEngineInterface extends MarginedEngineReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    feePool,
    initialMarginRatio,
    insuranceFund,
    liquidationFee,
    maintenanceMarginRatio,
    owner,
    partialLiquidationRatio
  }: {
    feePool?: string;
    initialMarginRatio?: Uint128;
    insuranceFund?: string;
    liquidationFee?: Uint128;
    maintenanceMarginRatio?: Uint128;
    owner?: string;
    partialLiquidationRatio?: Uint128;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  updatePauser: ({
    pauser
  }: {
    pauser: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  addWhitelist: ({
    address
  }: {
    address: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  removeWhitelist: ({
    address
  }: {
    address: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  openPosition: ({
    baseAssetLimit,
    leverage,
    marginAmount,
    side,
    vamm
  }: {
    baseAssetLimit: Uint128;
    leverage: Uint128;
    marginAmount: Uint128;
    side: Side;
    vamm: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  closePosition: ({
    quoteAssetLimit,
    vamm
  }: {
    quoteAssetLimit: Uint128;
    vamm: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  liquidate: ({
    quoteAssetLimit,
    trader,
    vamm
  }: {
    quoteAssetLimit: Uint128;
    trader: string;
    vamm: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  payFunding: ({
    vamm
  }: {
    vamm: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  depositMargin: ({
    amount,
    vamm
  }: {
    amount: Uint128;
    vamm: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawMargin: ({
    amount,
    vamm
  }: {
    amount: Uint128;
    vamm: string;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  setPause: ({
    pause
  }: {
    pause: boolean;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MarginedEngineClient extends MarginedEngineQueryClient implements MarginedEngineInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.updatePauser = this.updatePauser.bind(this);
    this.addWhitelist = this.addWhitelist.bind(this);
    this.removeWhitelist = this.removeWhitelist.bind(this);
    this.openPosition = this.openPosition.bind(this);
    this.closePosition = this.closePosition.bind(this);
    this.liquidate = this.liquidate.bind(this);
    this.payFunding = this.payFunding.bind(this);
    this.depositMargin = this.depositMargin.bind(this);
    this.withdrawMargin = this.withdrawMargin.bind(this);
    this.setPause = this.setPause.bind(this);
  }

  updateConfig = async ({
    feePool,
    initialMarginRatio,
    insuranceFund,
    liquidationFee,
    maintenanceMarginRatio,
    owner,
    partialLiquidationRatio
  }: {
    feePool?: string;
    initialMarginRatio?: Uint128;
    insuranceFund?: string;
    liquidationFee?: Uint128;
    maintenanceMarginRatio?: Uint128;
    owner?: string;
    partialLiquidationRatio?: Uint128;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        fee_pool: feePool,
        initial_margin_ratio: initialMarginRatio,
        insurance_fund: insuranceFund,
        liquidation_fee: liquidationFee,
        maintenance_margin_ratio: maintenanceMarginRatio,
        owner,
        partial_liquidation_ratio: partialLiquidationRatio
      }
    }, $fee, $memo, $funds);
  };
  updatePauser = async ({
    pauser
  }: {
    pauser: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_pauser: {
        pauser
      }
    }, $fee, $memo, $funds);
  };
  addWhitelist = async ({
    address
  }: {
    address: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_whitelist: {
        address
      }
    }, $fee, $memo, $funds);
  };
  removeWhitelist = async ({
    address
  }: {
    address: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_whitelist: {
        address
      }
    }, $fee, $memo, $funds);
  };
  openPosition = async ({
    baseAssetLimit,
    leverage,
    marginAmount,
    side,
    vamm
  }: {
    baseAssetLimit: Uint128;
    leverage: Uint128;
    marginAmount: Uint128;
    side: Side;
    vamm: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      open_position: {
        base_asset_limit: baseAssetLimit,
        leverage,
        margin_amount: marginAmount,
        side,
        vamm
      }
    }, $fee, $memo, $funds);
  };
  closePosition = async ({
    quoteAssetLimit,
    vamm
  }: {
    quoteAssetLimit: Uint128;
    vamm: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      close_position: {
        quote_asset_limit: quoteAssetLimit,
        vamm
      }
    }, $fee, $memo, $funds);
  };
  liquidate = async ({
    quoteAssetLimit,
    trader,
    vamm
  }: {
    quoteAssetLimit: Uint128;
    trader: string;
    vamm: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liquidate: {
        quote_asset_limit: quoteAssetLimit,
        trader,
        vamm
      }
    }, $fee, $memo, $funds);
  };
  payFunding = async ({
    vamm
  }: {
    vamm: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pay_funding: {
        vamm
      }
    }, $fee, $memo, $funds);
  };
  depositMargin = async ({
    amount,
    vamm
  }: {
    amount: Uint128;
    vamm: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_margin: {
        amount,
        vamm
      }
    }, $fee, $memo, $funds);
  };
  withdrawMargin = async ({
    amount,
    vamm
  }: {
    amount: Uint128;
    vamm: string;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_margin: {
        amount,
        vamm
      }
    }, $fee, $memo, $funds);
  };
  setPause = async ({
    pause
  }: {
    pause: boolean;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_pause: {
        pause
      }
    }, $fee, $memo, $funds);
  };
}